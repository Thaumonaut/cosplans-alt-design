# Data Model: Test Fixtures & Factories

**Date**: 2025-10-26  
**Feature**: 001-comprehensive-testing  
**Phase**: 1 (Design)

## Summary

This document defines the data structures, factories, and fixtures used across all test types (unit, integration, E2E). Test data is generated using the Factory Pattern with Faker.js for realistic values. Database isolation is achieved through schema namespaces, allowing parallel test execution without interference.

---

## Test Data Architecture

### Factory Pattern

Factories generate test data programmatically with sensible defaults and allow overriding specific fields for test scenarios.

**Benefits**:
- Type-safe (TypeScript ensures data matches schema)
- Maintainable (single source of truth)
- Flexible (customize specific fields)
- Realistic (Faker.js generates plausible data)
- Repeatable (seed control for deterministic tests)

**Location**: `tests/utils/factory.ts`

---

## Core Entities

### User Factory

```typescript
import { faker } from '@faker-js/faker';
import type { User, UserInsert } from '$lib/types/supabase';

export interface TestUser extends User {
  password?: string; // For E2E login tests
}

export function createTestUser(overrides: Partial<TestUser> = {}): TestUser {
  const firstName = faker.person.firstName();
  const lastName = faker.person.lastName();
  
  return {
    id: faker.string.uuid(),
    email: faker.internet.email({ firstName, lastName }).toLowerCase(),
    first_name: firstName,
    last_name: lastName,
    avatar_url: faker.image.avatar(),
    created_at: faker.date.past({ years: 1 }).toISOString(),
    updated_at: faker.date.recent({ days: 30 }).toISOString(),
    password: 'Test123!@#', // Default test password
    ...overrides
  };
}

export function createTestUserInsert(overrides: Partial<UserInsert> = {}): UserInsert {
  const user = createTestUser(overrides);
  delete user.id; // Insert doesn't include ID (generated by DB)
  return user as UserInsert;
}

// Predefined test users for consistent E2E tests
export const FIXED_TEST_USERS = {
  alice: createTestUser({
    email: 'alice@test.com',
    first_name: 'Alice',
    last_name: 'Cosplayer',
    password: 'AliceTest123!',
  }),
  bob: createTestUser({
    email: 'bob@test.com',
    first_name: 'Bob',
    last_name: 'Photographer',
    password: 'BobTest123!',
  }),
  charlie: createTestUser({
    email: 'charlie@test.com',
    first_name: 'Charlie',
    last_name: 'Teamlead',
    password: 'CharlieTest123!',
  }),
};
```

---

### Team Factory

```typescript
import type { Team, TeamInsert, TeamMember, TeamMemberInsert } from '$lib/types/supabase';

export function createTestTeam(overrides: Partial<Team> = {}): Team {
  return {
    id: faker.string.uuid(),
    name: faker.company.name(),
    description: faker.lorem.sentence(),
    owner_id: faker.string.uuid(),
    created_at: faker.date.past({ years: 1 }).toISOString(),
    updated_at: faker.date.recent({ days: 30 }).toISOString(),
    ...overrides
  };
}

export function createTestTeamInsert(overrides: Partial<TeamInsert> = {}): TeamInsert {
  const team = createTestTeam(overrides);
  delete team.id;
  return team as TeamInsert;
}

export function createTestTeamMember(overrides: Partial<TeamMember> = {}): TeamMember {
  return {
    id: faker.string.uuid(),
    team_id: faker.string.uuid(),
    user_id: faker.string.uuid(),
    role: faker.helpers.arrayElement(['owner', 'admin', 'member', 'viewer']),
    joined_at: faker.date.past({ years: 1 }).toISOString(),
    updated_at: faker.date.recent({ days: 30 }).toISOString(),
    ...overrides
  };
}

export function createPersonalTeam(userId: string): Team {
  return createTestTeam({
    name: 'Personal',
    description: 'Personal team for individual projects',
    owner_id: userId,
  });
}
```

---

### Project Factory

```typescript
import type { Project } from '$lib/types';

export function createTestProject(overrides: Partial<Project> = {}): Project {
  const budgetTotal = faker.number.int({ min: 500, max: 5000 });
  const budgetSpent = faker.number.int({ min: 0, max: budgetTotal });
  const progress = Math.round((budgetSpent / budgetTotal) * 100);
  
  return {
    id: faker.number.int({ min: 1, max: 999999 }),
    title: faker.commerce.productName(),
    character: faker.person.fullName(),
    series: faker.lorem.words(3),
    image: faker.image.urlPicsumPhotos({ width: 400, height: 600 }),
    progress,
    budget: {
      spent: budgetSpent,
      total: budgetTotal
    },
    deadline: faker.date.future({ years: 1 }).toISOString(),
    status: faker.helpers.arrayElement(['idea', 'planning', 'in-progress', 'completed', 'archived']),
    createdAt: faker.date.past({ years: 1 }),
    updatedAt: faker.date.recent({ days: 30 }),
    ...overrides
  };
}

// Status-specific factories for filtered views
export function createInProgressProject(overrides: Partial<Project> = {}): Project {
  return createTestProject({ status: 'in-progress', progress: faker.number.int({ min: 10, max: 90 }), ...overrides });
}

export function createCompletedProject(overrides: Partial<Project> = {}): Project {
  return createTestProject({ status: 'completed', progress: 100, ...overrides });
}

export function createArchivedProject(overrides: Partial<Project> = {}): Project {
  return createTestProject({ status: 'archived', progress: 100, ...overrides });
}

export function createIdeaProject(overrides: Partial<Project> = {}): Project {
  return createTestProject({ status: 'idea', progress: 0, ...overrides });
}

export function createPlanningProject(overrides: Partial<Project> = {}): Project {
  return createTestProject({ status: 'planning', progress: faker.number.int({ min: 0, max: 30 }), ...overrides });
}
```

---

### Task Factory

```typescript
import type { Task } from '$lib/types';

export function createTestTask(overrides: Partial<Task> = {}): Task {
  return {
    id: faker.number.int({ min: 1, max: 999999 }),
    title: faker.lorem.sentence({ min: 3, max: 6 }),
    description: faker.lorem.paragraph(),
    completed: faker.datatype.boolean(),
    projectId: faker.number.int({ min: 1, max: 999 }),
    dueDate: faker.date.future({ years: 1 }),
    priority: faker.helpers.arrayElement(['low', 'medium', 'high']),
    ...overrides
  };
}

// Priority-specific factories
export function createHighPriorityTask(overrides: Partial<Task> = {}): Task {
  return createTestTask({ priority: 'high', completed: false, ...overrides });
}

export function createOverdueTask(overrides: Partial<Task> = {}): Task {
  return createTestTask({ 
    dueDate: faker.date.past({ days: 7 }), 
    completed: false, 
    priority: 'high',
    ...overrides 
  });
}
```

---

### Event Factory

```typescript
import type { Event } from '$lib/types';

export function createTestEvent(overrides: Partial<Event> = {}): Event {
  return {
    id: faker.number.int({ min: 1, max: 999999 }),
    title: faker.lorem.sentence({ min: 2, max: 5 }),
    description: faker.lorem.paragraph(),
    date: faker.date.future({ years: 1 }),
    type: faker.helpers.arrayElement(['convention', 'photoshoot', 'deadline', 'other']),
    projectId: faker.number.int({ min: 1, max: 999 }),
    ...overrides
  };
}

// Type-specific factories
export function createConventionEvent(overrides: Partial<Event> = {}): Event {
  return createTestEvent({ type: 'convention', title: faker.company.name() + ' Con', ...overrides });
}

export function createPhotoshootEvent(overrides: Partial<Event> = {}): Event {
  return createTestEvent({ type: 'photoshoot', title: 'Photoshoot: ' + faker.location.city(), ...overrides });
}
```

---

### Character Factory

```typescript
import type { Character, CharacterInsert } from '$lib/types/supabase';

export function createTestCharacter(overrides: Partial<Character> = {}): Character {
  return {
    id: faker.string.uuid(),
    name: faker.person.fullName(),
    series: faker.lorem.words(3),
    source_medium: faker.helpers.arrayElement(['anime', 'manga', 'game', 'movie', 'tv', 'book', 'original']),
    team_id: faker.string.uuid(),
    reference_images: Array.from({ length: faker.number.int({ min: 1, max: 5 }) }, () => 
      faker.image.urlPicsumPhotos({ width: 400, height: 600 })
    ),
    budget_mode: faker.helpers.arrayElement(['personal', 'commission']),
    budget_limit: faker.number.int({ min: 100, max: 2000 }),
    completion_percentage: faker.number.int({ min: 0, max: 100 }),
    created_at: faker.date.past({ years: 1 }).toISOString(),
    updated_at: faker.date.recent({ days: 30 }).toISOString(),
    ...overrides
  };
}
```

---

## Test Data Seeding

### Schema Setup & Seeding

```typescript
// tests/integration/fixtures/test-schema.ts

export interface TestSchemaContext {
  schemaName: string;
  users: TestUser[];
  teams: Team[];
  projects: Project[];
  cleanup: () => Promise<void>;
}

export async function setupTestSchema(): Promise<TestSchemaContext> {
  // 1. Create isolated schema
  const schemaName = `test_${Date.now()}_${Math.random().toString(36).slice(2, 9)}`;
  await createSchema(schemaName);
  
  // 2. Copy table structure from public schema
  await cloneSchemaStructure('public', schemaName);
  
  // 3. Seed with basic test data
  const users = await seedUsers(schemaName);
  const teams = await seedTeams(schemaName, users);
  const projects = await seedProjects(schemaName, teams);
  
  return {
    schemaName,
    users,
    teams,
    projects,
    cleanup: async () => {
      await dropSchema(schemaName);
    }
  };
}

async function seedUsers(schemaName: string): Promise<TestUser[]> {
  const users = [
    FIXED_TEST_USERS.alice,
    FIXED_TEST_USERS.bob,
    FIXED_TEST_USERS.charlie,
  ];
  
  for (const user of users) {
    await supabase
      .schema(schemaName)
      .from('users')
      .insert(createTestUserInsert(user));
  }
  
  return users;
}

async function seedTeams(schemaName: string, users: TestUser[]): Promise<Team[]> {
  const teams: Team[] = [];
  
  // Create personal team for each user
  for (const user of users) {
    const team = createPersonalTeam(user.id);
    await supabase.schema(schemaName).from('teams').insert(team);
    await supabase.schema(schemaName).from('team_members').insert({
      team_id: team.id,
      user_id: user.id,
      role: 'owner'
    });
    teams.push(team);
  }
  
  // Create one shared private team
  const sharedTeam = createTestTeam({
    name: 'Shared Team',
    owner_id: users[0].id,
  });
  await supabase.schema(schemaName).from('teams').insert(sharedTeam);
  for (const user of users) {
    await supabase.schema(schemaName).from('team_members').insert({
      team_id: sharedTeam.id,
      user_id: user.id,
      role: user.id === users[0].id ? 'owner' : 'member'
    });
  }
  teams.push(sharedTeam);
  
  return teams;
}

async function seedProjects(schemaName: string, teams: Team[]): Promise<Project[]> {
  const projects: Project[] = [];
  
  // Create 2-3 projects per team
  for (const team of teams) {
    const projectCount = faker.number.int({ min: 2, max: 3 });
    for (let i = 0; i < projectCount; i++) {
      const project = createTestProject({ /* team_id: team.id */ });
      await supabase.schema(schemaName).from('projects').insert(project);
      projects.push(project);
    }
  }
  
  return projects;
}
```

---

## Test Fixtures (Static Data)

For specific edge cases where programmatic factories are insufficient, use static JSON fixtures.

### Location

- E2E fixtures: `tests/e2e/fixtures/`
- Integration fixtures: `tests/integration/fixtures/`

### Example: Edge Case Projects

```typescript
// tests/e2e/fixtures/edge-case-projects.ts

export const EDGE_CASE_PROJECTS = {
  // Project with no budget
  noBudget: {
    title: 'Free Project',
    character: 'Budget-Free Character',
    series: 'Test Series',
    budget: { spent: 0, total: 0 },
    status: 'in-progress',
  },
  
  // Project with overdue deadline
  overdue: {
    title: 'Overdue Project',
    character: 'Late Character',
    series: 'Test Series',
    deadline: '2020-01-01T00:00:00Z', // Past date
    status: 'in-progress',
  },
  
  // Project with very long title (boundary testing)
  longTitle: {
    title: 'A'.repeat(500), // 500 character title
    character: 'Long Title Character',
    series: 'Test Series',
    status: 'idea',
  },
  
  // Project with special characters
  specialChars: {
    title: 'Project with Ã©mojis ðŸŽ­ðŸŽ¨ and spÃ«cial Ã§hars',
    character: 'Specialâ„¢ CharacterÂ®',
    series: 'Testâ„¢ SeriesÂ®',
    status: 'planning',
  },
};
```

---

## Database Schema Isolation Utilities

### Schema Lifecycle Management

```typescript
// tests/utils/test-database.ts

import { createClient } from '@supabase/supabase-js';
import type { Database } from '$lib/types/supabase';

const TEST_SUPABASE_URL = process.env.SUPABASE_TEST_URL!;
const TEST_SUPABASE_KEY = process.env.SUPABASE_TEST_KEY!;

export const testSupabase = createClient<Database>(TEST_SUPABASE_URL, TEST_SUPABASE_KEY);

/**
 * Create a new test schema with a unique name
 */
export async function createSchema(schemaName: string): Promise<void> {
  const { error } = await testSupabase.rpc('create_test_schema', { schema_name: schemaName });
  if (error) throw new Error(`Failed to create schema ${schemaName}: ${error.message}`);
}

/**
 * Clone table structure from source schema to target schema
 */
export async function cloneSchemaStructure(sourceSchema: string, targetSchema: string): Promise<void> {
  const { error } = await testSupabase.rpc('clone_schema_structure', {
    source_schema: sourceSchema,
    target_schema: targetSchema,
  });
  if (error) throw new Error(`Failed to clone schema structure: ${error.message}`);
}

/**
 * Drop a test schema and all its tables
 */
export async function dropSchema(schemaName: string): Promise<void> {
  const { error } = await testSupabase.rpc('drop_test_schema', { schema_name: schemaName });
  if (error) console.error(`Failed to drop schema ${schemaName}:`, error.message);
  // Don't throw - cleanup errors shouldn't fail tests
}

/**
 * List all test schemas (for manual cleanup if tests crash)
 */
export async function listTestSchemas(): Promise<string[]> {
  const { data, error } = await testSupabase.rpc('list_test_schemas');
  if (error) throw new Error(`Failed to list test schemas: ${error.message}`);
  return data as string[];
}

/**
 * Cleanup orphaned test schemas (older than 1 hour)
 */
export async function cleanupOrphanedSchemas(): Promise<void> {
  const schemas = await listTestSchemas();
  const oneHourAgo = Date.now() - 60 * 60 * 1000;
  
  for (const schema of schemas) {
    // Extract timestamp from schema name (test_<timestamp>_<random>)
    const match = schema.match(/^test_(\d+)_/);
    if (match) {
      const timestamp = parseInt(match[1], 10);
      if (timestamp < oneHourAgo) {
        console.log(`Cleaning up orphaned schema: ${schema}`);
        await dropSchema(schema);
      }
    }
  }
}
```

### Required Database Functions (SQL)

These functions must be created in the test Supabase project:

```sql
-- Create a new schema
CREATE OR REPLACE FUNCTION create_test_schema(schema_name TEXT)
RETURNS VOID AS $$
BEGIN
  EXECUTE format('CREATE SCHEMA IF NOT EXISTS %I', schema_name);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Clone table structure from one schema to another
CREATE OR REPLACE FUNCTION clone_schema_structure(source_schema TEXT, target_schema TEXT)
RETURNS VOID AS $$
DECLARE
  table_record RECORD;
BEGIN
  FOR table_record IN 
    SELECT tablename FROM pg_tables WHERE schemaname = source_schema
  LOOP
    EXECUTE format(
      'CREATE TABLE %I.%I (LIKE %I.%I INCLUDING ALL)',
      target_schema, table_record.tablename,
      source_schema, table_record.tablename
    );
  END LOOP;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop a test schema (cascade to remove all tables)
CREATE OR REPLACE FUNCTION drop_test_schema(schema_name TEXT)
RETURNS VOID AS $$
BEGIN
  IF schema_name LIKE 'test_%' THEN
    EXECUTE format('DROP SCHEMA IF EXISTS %I CASCADE', schema_name);
  ELSE
    RAISE EXCEPTION 'Only test schemas (test_*) can be dropped via this function';
  END IF;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- List all test schemas
CREATE OR REPLACE FUNCTION list_test_schemas()
RETURNS TEXT[] AS $$
  SELECT array_agg(schema_name::TEXT)
  FROM information_schema.schemata
  WHERE schema_name LIKE 'test_%';
$$ LANGUAGE sql SECURITY DEFINER;
```

---

## Test Data Cleanup

### Integration Test Pattern

```typescript
// Example integration test with schema isolation
import { describe, it, expect, beforeAll, afterAll } from 'vitest';
import { setupTestSchema, type TestSchemaContext } from '../fixtures/test-schema';

describe('Project Service', () => {
  let context: TestSchemaContext;

  beforeAll(async () => {
    context = await setupTestSchema();
  });

  afterAll(async () => {
    await context.cleanup();
  });

  it('creates a project', async () => {
    const project = createTestProject({ /* team_id: context.teams[0].id */ });
    
    // Service will use context.schemaName to scope queries
    const result = await projectService.create(project, context.schemaName);
    
    expect(result).toBeDefined();
    expect(result.title).toBe(project.title);
  });
});
```

### E2E Test Pattern

```typescript
// Example E2E test with page objects and fixtures
import { test, expect } from '@playwright/test';
import { LoginPage } from '../support/page-objects/LoginPage';
import { DashboardPage } from '../support/page-objects/DashboardPage';
import { FIXED_TEST_USERS } from '../fixtures/test-users';

test.describe('Project Management', () => {
  test('user can create a project', async ({ page }) => {
    // Login with fixed test user
    const loginPage = new LoginPage(page);
    await loginPage.goto();
    await loginPage.login(FIXED_TEST_USERS.alice.email, FIXED_TEST_USERS.alice.password);
    
    // Navigate to dashboard
    const dashboardPage = new DashboardPage(page);
    await dashboardPage.clickCreateProject();
    
    // Fill project form
    const project = createTestProject();
    await dashboardPage.fillProjectForm(project);
    await dashboardPage.submitProjectForm();
    
    // Verify project created
    await expect(page.locator(`text=${project.title}`)).toBeVisible();
  });
});
```

---

## Factory Utilities

### Batch Creation

```typescript
// tests/utils/factory.ts

export function createTestUsers(count: number, overrides: Partial<TestUser> = {}): TestUser[] {
  return Array.from({ length: count }, () => createTestUser(overrides));
}

export function createTestProjects(count: number, overrides: Partial<Project> = {}): Project[] {
  return Array.from({ length: count }, () => createTestProject(overrides));
}

export function createTestTasks(count: number, overrides: Partial<Task> = {}): Task[] {
  return Array.from({ length: count }, () => createTestTask(overrides));
}
```

### Seeded Randomness (Deterministic Tests)

```typescript
import { faker } from '@faker-js/faker';

// For deterministic tests (same data every run)
export function useDeterministicFactory() {
  faker.seed(12345); // Fixed seed
}

// For randomized tests (different data every run)
export function useRandomFactory() {
  faker.seed(Date.now());
}

// Default: random (catches more edge cases)
useRandomFactory();
```

---

## Summary

This data model provides:

1. **Type-safe factories** for all core entities (users, teams, projects, tasks, events, characters)
2. **Schema isolation utilities** for parallel test execution
3. **Predefined fixtures** for consistent E2E tests (FIXED_TEST_USERS)
4. **Edge case fixtures** for boundary testing
5. **Cleanup utilities** for test data lifecycle management
6. **Database functions** for schema management (SQL migrations required)

All test types (unit, integration, E2E) use the same factory system for consistency. Factories generate realistic data with Faker.js while allowing overrides for specific test scenarios.


